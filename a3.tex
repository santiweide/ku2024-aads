\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{upquote}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
\usepackage{listings}
\newenvironment{statement}[2][Statement]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\usepackage{xcolor}




\title{Assignment 3}


\author{Author \\
  Wanjing Hu / fng685@alumni.ku.dk  \\
  Zhigao Yan / sxd343@alumni.ku.dk  \\
  Wenshuo Dong / gnj461@alumni.ku.dk  \\
  Jiayi Zhang / xrw579@alumni.ku.dk \\
} 
 

\begin{document}
\maketitle
% The ones marked * are the hard, and will get larger weight.

\section{Hashing-2.1}
\textbf{Question: } Is the truly independent hash function h : U $\rightarrow$ [m] universal?
%wanjing

Yes. 

Our reason is that for truly independent hash function, for any input $x_i \in U$, $i = 1,2,...,n$, the outputs $h(x_i)$ are completely independent and uniformly distributed over $[m]={0,1,...,m-1}$. Assume we are picking the value $k$ such that $h(x)=k$ , then we have

\begin{equation}
\begin{aligned}
\mathop{Pr} \limits_{h} [h(x)=k] \leq \frac{1}{m}\\
\mathop{Pr} \limits_{h} [h(y)=k] \leq \frac{1}{m}\\
\end{aligned}
\end{equation}
That is $Pr[h(x)=h(y)] \leq \frac{1}{m}$. So the truly independent hash function h : U $\rightarrow$ [m] is universal.

\section{Hashing-2.2}
\textbf{Question:} If a hash function h : U → [m] has collision probability 0, how large must m be?

The collision probability is 0 which means:
\[\mathop{Pr} \limits_{h}[h(x)=h(y)] =0\]
So, the minimum size of m should be equal to \(|U|\), in other words \(|m|\geq|U|\)
%zhigao

\section{Hashing-2.3}
%wenshuo

\section{Hashing-2.4 }
% in (b) assume x is not in S
%jiayi

\section{Hashing-2.5*}
%wanjing
\textbf{Question: }
With $s: U \rightarrow [n^3]$ and $h : U \rightarrow [n]$ independent universal hash functions, for a given $x \in U \backslash S$, what is the probability of a false positive when we search $x$, that is, what is the probability that there is a key $y \in S$ such that $h(y) = h(x)$ and $s(y) = s(x)$?

\textbf{Answer}

Now we have:
\begin{equation}
\begin{aligned}
\mathop{Pr} \limits_{h} [h(x)=h(y)] &= \frac{1}{n}\\
\mathop{Pr} \limits_{s} [s(x)=s(y)] &= \frac{1}{n^3}
\end{aligned}
\end{equation}

And we want to know about:
\begin{equation}
\begin{aligned}
&\mathop{Pr}  [False \, Positive]\\
&= Pr[\exists y \in S \, such \, that \, h(y) = h(x) \, and \, s(y) = s(x)]\\
&<= \sum_{y \in S} Pr[h(x)=h(y) \, and \, s(y)=s(x)]
\end{aligned}
\end{equation}

The inequality is a union bound, that the probability of that at least one of multiple events happen is at most the sum of their probabilities(reference to the hashing material provided in class). Since h and s are independent, for any single $y \in S$ we have:
\begin{equation}
\begin{aligned}
&\mathop{Pr} [h(x)=h(y) \, and \, s(y)=s(x)] \\
&\mathop{Pr} [h(x)=h(y)] * \mathop{Pr} \limits_{h,s} [s(x)=s(y)] \\
&= \frac{1}{n^4}
\end{aligned}
\end{equation}

So we have
\begin{equation}
\begin{aligned}
&\mathop{Pr}  [False \, Positive]\\
&<= |S|/n^4
\end{aligned}
\end{equation}

Where $|S|$ is the size of set S.

\section{Hashing-2.6*}
\textbf{Question:}
Suppose we for our hash function also consider a = 0, that is, for random \((a, b)\in[p]^2\), we define the hash function \(h_{a,b} : [p] \rightarrow [m]\) by
\[h_{a,b}(x) = ((ax + b)\mod{p} )\mod{m}\]

(a) Show that this function may not be universal.\\


For this question, I need to show that in some cases:
\[Pr_{(a,b)\in[p]^2}[h_{a,b}(x) = h_{a,b}(y)] > 1/m\]
Consider a = 0, we can get:
\[h_{a,b}(x) = ((ax + b)\mod{p} )\mod{m} = (b\mod{p} )\mod{m}\]
In that case:
\[h_{0,b}(x) = (b\mod{p} )\mod{m}\]
\[h_{0,b}(y) = (b\mod{p} )\mod{m}\]
we can see the value of \(h_{a,b}(x)\) is only depending on b, and the collision probability is 1.\\
\\
(b) Prove that it is always 2-approximately universal, that is, for any distinct \(x, y \in [p]\), 
\[Pr_{(a,b)\in[p]^2}[h_{a,b}(x) = h_{a,b}(y)] < 2/m\]


From the previous proof, we know that when \(a \neq 0\):
\[Pr_{(a,b)\in[p]^2}[h_{a,b}(x) = h_{a,b}(y)] < 1/m\]
And the probability of \(a \neq 0\) is \(\frac{p-1}{p}\).
So we can calculate the probability of two cases:
\[
Pr[h_{a,b}(x) = h_{a,b}(y)] = Pr[a = 0] \cdot 1 + Pr[a \neq 0] \cdot \frac{1}{m}.
\]
\[
Pr[h_{a,b}(x) = h_{a,b}(y)] = \frac{1}{p} + \frac{p-1}{p} \cdot \frac{1}{m}.
\]
From the question we can get \(p>m\), Hence:
\[\frac{1}{p} + \frac{p-1}{p} \cdot \frac{1}{m}<\frac{2}{m}\]
Finally, Substitute into the inequality:
\[Pr_{(a,b)\in[p]^2}[h_{a,b}(x) = h_{a,b}(y)] < 2/m\]



%zhigao

\section{Hashing-3.1}
%wenshuo

\section{Hashing-3.2}
%jiayi

\section{Hashing-3.3* }
% you must prove that the collision probability is at most c/m. It is not sufficient to prove c²/m
%wanjing
\textbf{Question: }
Argue that if $h: U \rightarrow [m]$ is c-approximately strong universal, then h is also c-approximately universal.

\textbf{Answer}
The collision probability of the c-approximately strong universal is 

\begin{equation}
\begin{aligned}
&Pr[h(x)=h(y)] \\
&= \sum_{q \in [m]} Pr[h(x) = q \, and \, h(y) = q]\\
&= \sum_{q \in [m]} Pr[h(x) = q \, and \, h(y) = h(x)]\\
&=\sum_{q \in [m]} Pr[h(x) = q] * Pr[h(y) = h(x)]\\
&=\sum_{q \in [m]} Pr[h(x) = q] *1/m
\end{aligned}
\end{equation}

For the last equation we use the independency property of c-approximately universal. And we also have:
\begin{equation}
\begin{aligned}
Pr[h(x) = q] &<= \frac{c}{m} \\
\end{aligned}
\end{equation}

So we have
\begin{equation}
\begin{aligned}
&Pr[h(x)=h(y)] \\
&= \sum_{q \in [m]} Pr[h(x) = q] * 1/m\\
&<=\sum_{q \in [m]}   \frac{c}{m^2}
= \frac{c}{m}
\end{aligned}
\end{equation}

\section{Hashing-3.4*}
\textbf{Question:} Is Multiply-Shift c-approximately strongly universal for any constant c?
% hint: the answer is no, because not all pairs of keys hash independently - your job is to prove this.
%zhigao... wanjing done but...not sure....
\textbf{Question} Is Multiply-Shift c-approximately strongly universal for any constant c?

\textbf{Answer}
No. Here we have found a possible pair of $x$ and $y$ that contradicts the definition of strong universality.

According to the Observation3.1 in the textbook, an equivalent definition of strong universality is that each key is hashed uniformly into [m], and that every two distinct keys are hashed independently.

For $x$ we have 

\begin{equation}
\begin{aligned}
h(x) = \lfloor \frac{a * x \mod 2^w}{2^{w-l}} \rfloor
\end{aligned}
\end{equation}

Pick $y=x+2^{l}$, we have :
\begin{equation}
\begin{aligned}
h(y) &= \lfloor \frac{a*(x+2^l)  \mod 2^w }{2^{w-l}} \rfloor \\
&= \lfloor \frac{a*x \mod 2^w + a * 2^l \mod \, 2^w }{2^{w-l}} \rfloor \\
&= \lfloor \frac{a*x \mod 2^w + a * 2^l }{2^{w-l}} \rfloor \\
&= \lfloor \frac{a*x \mod 2^w }{2^{w-l}}  + a * 2^{2*l-w} \rfloor \\
\end{aligned}
\end{equation}

We can see when $a=2^{w-2*l}$, there will be a possibility of $h(x) = h(y)$, when the floor is passed, and thus not all pairs of distinct keys will hash indepedently.


No, because not all pairs of keys hash independently.\\
\textbf{Proof}:\\
For \(h(x)=q\) and \(h(y) = r\), we have:
\[\left\lfloor \frac{(a \cdot x) \mod 2^w}{2^{w-\ell}} \right\rfloor=q\]
\[\left\lfloor \frac{(a \cdot y) \mod 2^w}{2^{w-\ell}} \right\rfloor=r\]
Consider \(x=0, \quad y\neq0\), For \(h(x)\), we get:
\[\left\lfloor \frac{(a \cdot x) \mod 2^w}{2^{w-\ell}} \right\rfloor=0\]
Regardless of the value of a, \(h(0)\) is always equal to 0.

For \(h(x)=h(y)\), based on the definition of Multiply-Shift, we get:

\[\left\lfloor \frac{(a \cdot x) \mod 2^w}{2^{w-\ell}} \right\rfloor = \left\lfloor \frac{(a \cdot y) \mod 2^w}{2^{w-\ell}} \right\rfloor\]



\section{Hashing-3.5}
%wenshuo

\section{Hashing-3.6}
%jiayi

\section{Complexity-34.1-1}
%wanjing
\textbf{Question}
Define the optimization problem $LONGEST-PATH-LENGTH$ as the relation that associates each instance of an undirected graph and two vertices with the number of edges in a longest simple path between the two vertices. Define the decision problem $LONGEST-PATH= \{\langle G, u, v, k\rangle: G = (V, E)$ is an undirected graph, $u, v \in V, k \ge 0$ is an integer, and there exists a simple path from $u$ to $v$ in $G$ consisting of at least $k$ edges $\}$. Show that the optimization problem $LONGEST-PATH-LENGTH$ can be solved in polynomial time if and only if $LONGEST-PATH \in P$.

\textbf{Answer}

We split the target into two cases to prove, one is to prove when the $LONGEST-PATH \subseteq P$, the $LONGEST-PATH-LENGTH \subseteq P$(Note as A), and the other is when he $LONGEST-PATH-LENGTH \subseteq P$, the $LONGEST-PATH \subseteq P$(Note as B).
 
\subsection{Proof of A}
Assume the $LONGEST-PATH \subseteq P$, and we apply binary search for finding the longest path length. The steps are as follows:

\textbf{Initialize} Initialize $low = 0$ and $high = |V| - 1$, for the path visits each vertex exactly once, and the longest path in a graph cannot exceed $|V| - 1$ edges . 

\textbf{Step1} Set $mid = \lfloor (low + high) / 2 \rfloor$.

\textbf{Step2} Use the polynomial-time algorithm for $LONGEST-PATH$ to check if there is a path of length at least $mid$ from $u$ to $v$.

\textbf{Step3} If yes, it means there may be a longer path, and we update $low = mid + 1$.

\textbf{Step4} If no, it means the longest path is shorter than current range, and we update $high = mid - 1$.

\textbf{Result} The value of $high$ at the end of the search will give the length of the longest simple path between $u$ and $v$.

Since the decision problem runs in polynomial time, and binary search over $|V|$ iterations requires at most $O(\log |V|)$ queries, the entire process is polynomial in the size of the graph.

\subsection{Proof of B}
Assume the $LONGEST-PATH-LENGTH \subseteq P$, and then we apply deep first search. The Algorithm steps as follows:
 
\textbf{Initialize} Push a tuple $<u, 0, path>$ to a Stack $S$, where path is an empty string. Set the result path vector $res$ to be empty. The begin a loop, while $S$ is not empty:

\textbf{Step1} Pop one tuple of $<vertex, counter, path>$ from $S$, note as $<s, c>$. 

\textbf{Step2} Run the $LONGEST-PATH-LENGTH$ to compute the longest path length $len$ between $s$ and $v$, which costs polynomial-time.

\textbf{Step3} If $len \geq k-c$, for all the vertex $s'$ that having an edge out of $s$, push $<s', c+1, path+s>$ into $S$.

\textbf{Step4} If $s = v$ and $c \ge k$, then $path + v$ is an possible answer, and we can break the loop.   

\textbf{Step5} When the loop is end and there is no answer output, there is no max length path.

\textbf{Complexity Analysis}

 $LONGEST-PATH-LENGTH$ runs in polynomial time by assumption.

The DFS runs in $O(|V| + |E|)$ time.

Overall, the algorithm runs in polynomial time because the DFS and path length comparison are polynomial operations.



\section{Complexity-34.1-5}
%zhigao

\section{Complexity-34.2-5}
%wenshuo

\section{Complexity-34.2-6}
%jiayi

\section{Complexity-34.2-8}
%wanjing
\textbf{Question}
Let $\phi$ be a boolean formula constructed from the boolean input variables $x_1, x_2, \dots, x_k$, negations ($\neg$), ANDs ($\vee$), ORs ($\wedge$), and parentheses. The formula $\phi$ is a \textit{\textbf{tautology}} if it evaluates to $1$ for every assignment of $1$ and $0$ to the input variables. Define $TAUTOLOGY$ as the language of boolean formulas that are tautologies. Show that $TAUTOLOGY \in co-NP$.

\textbf{Answer}
To verify $TAUTOLOGY \in co-NP$ we need to prove $\overline{TAUTOLOGY} \in NP$.

\subsection{Certificate}
The certificate for $\overline{TAUTOLOGY}$ is the assignment $(x_1,x_2,...,x_k) \in {0,1}^k$ such that $\phi(x_1,x_2,...,x_k) = 0$.

\subsection{Verifier}
The verifier is defined as follows:

\textbf{Step1} Substitute each $x_i$ in $\phi$ with the corresponding value in the certificate.

\textbf{Step2} Evaluate based on the negations ($\neg$), ANDs ($\vee$), ORs ($\wedge$), and parentheses, which costs polynomial time in the size of $\phi$.

\textbf{Step3} Check if the result of the evaluation is 0, which would be accepted. Otherwise it will be rejected. 

Since the complexity is polynomial time in the size of $\phi$, $\overline{TAUTOLOGY} \in NP$.

\section{Complexity-34.3-2}
%zhigao

\section{Complexity-34.3-3}
%wenshuo

\end{document}
